{"ast":null,"code":"// Text summarization utilities implementing TextRank and LexRank algorithms\n\n// Simple sentence tokenizer\nfunction tokenizeSentences(text) {\n  return text.split(/[.!?]+/).map(s => s.trim()).filter(s => s.length > 10); // Filter out very short sentences\n}\n\n// Calculate cosine similarity between two sentences\nfunction cosineSimilarity(sent1, sent2) {\n  const words1 = sent1.toLowerCase().split(/\\s+/);\n  const words2 = sent2.toLowerCase().split(/\\s+/);\n  const allWords = Array.from(new Set([...words1, ...words2]));\n  const vector1 = allWords.map(word => words1.filter(w => w === word).length);\n  const vector2 = allWords.map(word => words2.filter(w => w === word).length);\n  const dotProduct = vector1.reduce((sum, val, i) => sum + val * vector2[i], 0);\n  const magnitude1 = Math.sqrt(vector1.reduce((sum, val) => sum + val * val, 0));\n  const magnitude2 = Math.sqrt(vector2.reduce((sum, val) => sum + val * val, 0));\n  return magnitude1 && magnitude2 ? dotProduct / (magnitude1 * magnitude2) : 0;\n}\n\n// TextRank implementation\nexport function textRankSummarize(text, numSentences = 3) {\n  const startTime = Date.now();\n  const sentences = tokenizeSentences(text);\n  if (sentences.length <= numSentences) {\n    return {\n      method: 'TextRank',\n      summary: sentences.join('. ') + '.',\n      sentences,\n      processingTime: Date.now() - startTime\n    };\n  }\n\n  // Build similarity matrix\n  const similarityMatrix = [];\n  for (let i = 0; i < sentences.length; i++) {\n    similarityMatrix[i] = [];\n    for (let j = 0; j < sentences.length; j++) {\n      if (i === j) {\n        similarityMatrix[i][j] = 0;\n      } else {\n        similarityMatrix[i][j] = cosineSimilarity(sentences[i], sentences[j]);\n      }\n    }\n  }\n\n  // PageRank algorithm\n  const scores = new Array(sentences.length).fill(1);\n  const damping = 0.85;\n  const iterations = 50;\n  for (let iter = 0; iter < iterations; iter++) {\n    const newScores = [...scores];\n    for (let i = 0; i < sentences.length; i++) {\n      let sum = 0;\n      for (let j = 0; j < sentences.length; j++) {\n        if (i !== j) {\n          const totalSim = similarityMatrix[j].reduce((a, b) => a + b, 0);\n          if (totalSim > 0) {\n            sum += similarityMatrix[j][i] / totalSim * scores[j];\n          }\n        }\n      }\n      newScores[i] = 1 - damping + damping * sum;\n    }\n    scores.splice(0, scores.length, ...newScores);\n  }\n\n  // Get top sentences\n  const rankedSentences = sentences.map((sentence, index) => ({\n    sentence,\n    score: scores[index],\n    index\n  })).sort((a, b) => b.score - a.score).slice(0, numSentences).sort((a, b) => a.index - b.index);\n  const summary = rankedSentences.map(item => item.sentence).join('. ') + '.';\n  return {\n    method: 'TextRank',\n    summary,\n    sentences: rankedSentences.map(item => item.sentence),\n    processingTime: Date.now() - startTime\n  };\n}\n\n// LexRank implementation\nexport function lexRankSummarize(text, numSentences = 3) {\n  const startTime = Date.now();\n  const sentences = tokenizeSentences(text);\n  if (sentences.length <= numSentences) {\n    return {\n      method: 'LexRank',\n      summary: sentences.join('. ') + '.',\n      sentences,\n      processingTime: Date.now() - startTime\n    };\n  }\n\n  // Build similarity matrix\n  const threshold = 0.1;\n  const similarityMatrix = [];\n  for (let i = 0; i < sentences.length; i++) {\n    similarityMatrix[i] = [];\n    for (let j = 0; j < sentences.length; j++) {\n      const similarity = cosineSimilarity(sentences[i], sentences[j]);\n      similarityMatrix[i][j] = similarity > threshold ? similarity : 0;\n    }\n  }\n\n  // Normalize rows\n  for (let i = 0; i < sentences.length; i++) {\n    const rowSum = similarityMatrix[i].reduce((a, b) => a + b, 0);\n    if (rowSum > 0) {\n      for (let j = 0; j < sentences.length; j++) {\n        similarityMatrix[i][j] /= rowSum;\n      }\n    }\n  }\n\n  // Power iteration\n  const scores = new Array(sentences.length).fill(1 / sentences.length);\n  const iterations = 50;\n  for (let iter = 0; iter < iterations; iter++) {\n    const newScores = new Array(sentences.length).fill(0);\n    for (let i = 0; i < sentences.length; i++) {\n      for (let j = 0; j < sentences.length; j++) {\n        newScores[i] += similarityMatrix[j][i] * scores[j];\n      }\n    }\n    scores.splice(0, scores.length, ...newScores);\n  }\n\n  // Get top sentences\n  const rankedSentences = sentences.map((sentence, index) => ({\n    sentence,\n    score: scores[index],\n    index\n  })).sort((a, b) => b.score - a.score).slice(0, numSentences).sort((a, b) => a.index - b.index);\n  const summary = rankedSentences.map(item => item.sentence).join('. ') + '.';\n  return {\n    method: 'LexRank',\n    summary,\n    sentences: rankedSentences.map(item => item.sentence),\n    processingTime: Date.now() - startTime\n  };\n}\n\n// Simple extractive summarization (frequency-based)\nexport function frequencyBasedSummarize(text, numSentences = 3) {\n  const startTime = Date.now();\n  const sentences = tokenizeSentences(text);\n  if (sentences.length <= numSentences) {\n    return {\n      method: 'Frequency-Based',\n      summary: sentences.join('. ') + '.',\n      sentences,\n      processingTime: Date.now() - startTime\n    };\n  }\n\n  // Calculate word frequencies\n  const words = text.toLowerCase().match(/\\b\\w+\\b/g) || [];\n  const wordFreq = {};\n  words.forEach(word => {\n    if (word.length > 3) {\n      // Ignore short words\n      wordFreq[word] = (wordFreq[word] || 0) + 1;\n    }\n  });\n\n  // Score sentences based on word frequencies\n  const sentenceScores = sentences.map(sentence => {\n    const sentenceWords = sentence.toLowerCase().match(/\\b\\w+\\b/g) || [];\n    const score = sentenceWords.reduce((sum, word) => sum + (wordFreq[word] || 0), 0);\n    return score / sentenceWords.length; // Normalize by sentence length\n  });\n\n  // Get top sentences\n  const rankedSentences = sentences.map((sentence, index) => ({\n    sentence,\n    score: sentenceScores[index],\n    index\n  })).sort((a, b) => b.score - a.score).slice(0, numSentences).sort((a, b) => a.index - b.index);\n  const summary = rankedSentences.map(item => item.sentence).join('. ') + '.';\n  return {\n    method: 'Frequency-Based',\n    summary,\n    sentences: rankedSentences.map(item => item.sentence),\n    processingTime: Date.now() - startTime\n  };\n}","map":{"version":3,"names":["tokenizeSentences","text","split","map","s","trim","filter","length","cosineSimilarity","sent1","sent2","words1","toLowerCase","words2","allWords","Array","from","Set","vector1","word","w","vector2","dotProduct","reduce","sum","val","i","magnitude1","Math","sqrt","magnitude2","textRankSummarize","numSentences","startTime","Date","now","sentences","method","summary","join","processingTime","similarityMatrix","j","scores","fill","damping","iterations","iter","newScores","totalSim","a","b","splice","rankedSentences","sentence","index","score","sort","slice","item","lexRankSummarize","threshold","similarity","rowSum","frequencyBasedSummarize","words","match","wordFreq","forEach","sentenceScores","sentenceWords"],"sources":["/Users/averyreyna/Codebases/rerank/src/utils/textSummarization.ts"],"sourcesContent":["// Text summarization utilities implementing TextRank and LexRank algorithms\nimport Sentiment from 'sentiment';\n\nexport interface QualityMetrics {\n  coverage: number; // 0-1, how much of the original text is represented\n  coherence: number; // 0-1, how well sentences flow together\n  diversity: number; // 0-1, how diverse the vocabulary is\n  confidence: number; // 0-1, overall confidence in the summary\n  sentiment: {\n    score: number;\n    comparative: number;\n    positive: string[];\n    negative: string[];\n  };\n}\n\nexport interface SentenceNode {\n  id: string;\n  text: string;\n  score: number;\n  sentiment: number;\n  connections: { target: string; weight: number }[];\n  position?: { x: number; y: number };\n}\n\nexport interface TopicCluster {\n  id: string;\n  keywords: string[];\n  sentences: string[];\n  centroid: number[];\n  color: string;\n}\n\nexport interface SummaryResult {\n  method: string;\n  summary: string;\n  sentences: string[];\n  processingTime: number;\n  qualityMetrics: QualityMetrics;\n  visualizationData: {\n    sentenceGraph: SentenceNode[];\n    topicClusters: TopicCluster[];\n  };\n}\n\n// Simple sentence tokenizer\nfunction tokenizeSentences(text: string): string[] {\n  return text\n    .split(/[.!?]+/)\n    .map(s => s.trim())\n    .filter(s => s.length > 10); // Filter out very short sentences\n}\n\n// Calculate cosine similarity between two sentences\nfunction cosineSimilarity(sent1: string, sent2: string): number {\n  const words1 = sent1.toLowerCase().split(/\\s+/);\n  const words2 = sent2.toLowerCase().split(/\\s+/);\n  \n  const allWords = Array.from(new Set([...words1, ...words2]));\n  \n  const vector1 = allWords.map(word => words1.filter(w => w === word).length);\n  const vector2 = allWords.map(word => words2.filter(w => w === word).length);\n  \n  const dotProduct = vector1.reduce((sum, val, i) => sum + val * vector2[i], 0);\n  const magnitude1 = Math.sqrt(vector1.reduce((sum, val) => sum + val * val, 0));\n  const magnitude2 = Math.sqrt(vector2.reduce((sum, val) => sum + val * val, 0));\n  \n  return magnitude1 && magnitude2 ? dotProduct / (magnitude1 * magnitude2) : 0;\n}\n\n// TextRank implementation\nexport function textRankSummarize(text: string, numSentences: number = 3): SummaryResult {\n  const startTime = Date.now();\n  const sentences = tokenizeSentences(text);\n  \n  if (sentences.length <= numSentences) {\n    return {\n      method: 'TextRank',\n      summary: sentences.join('. ') + '.',\n      sentences,\n      processingTime: Date.now() - startTime\n    };\n  }\n  \n  // Build similarity matrix\n  const similarityMatrix: number[][] = [];\n  for (let i = 0; i < sentences.length; i++) {\n    similarityMatrix[i] = [];\n    for (let j = 0; j < sentences.length; j++) {\n      if (i === j) {\n        similarityMatrix[i][j] = 0;\n      } else {\n        similarityMatrix[i][j] = cosineSimilarity(sentences[i], sentences[j]);\n      }\n    }\n  }\n  \n  // PageRank algorithm\n  const scores = new Array(sentences.length).fill(1);\n  const damping = 0.85;\n  const iterations = 50;\n  \n  for (let iter = 0; iter < iterations; iter++) {\n    const newScores = [...scores];\n    for (let i = 0; i < sentences.length; i++) {\n      let sum = 0;\n      for (let j = 0; j < sentences.length; j++) {\n        if (i !== j) {\n          const totalSim = similarityMatrix[j].reduce((a, b) => a + b, 0);\n          if (totalSim > 0) {\n            sum += (similarityMatrix[j][i] / totalSim) * scores[j];\n          }\n        }\n      }\n      newScores[i] = (1 - damping) + damping * sum;\n    }\n    scores.splice(0, scores.length, ...newScores);\n  }\n  \n  // Get top sentences\n  const rankedSentences = sentences\n    .map((sentence, index) => ({ sentence, score: scores[index], index }))\n    .sort((a, b) => b.score - a.score)\n    .slice(0, numSentences)\n    .sort((a, b) => a.index - b.index);\n  \n  const summary = rankedSentences.map(item => item.sentence).join('. ') + '.';\n  \n  return {\n    method: 'TextRank',\n    summary,\n    sentences: rankedSentences.map(item => item.sentence),\n    processingTime: Date.now() - startTime\n  };\n}\n\n// LexRank implementation\nexport function lexRankSummarize(text: string, numSentences: number = 3): SummaryResult {\n  const startTime = Date.now();\n  const sentences = tokenizeSentences(text);\n  \n  if (sentences.length <= numSentences) {\n    return {\n      method: 'LexRank',\n      summary: sentences.join('. ') + '.',\n      sentences,\n      processingTime: Date.now() - startTime\n    };\n  }\n  \n  // Build similarity matrix\n  const threshold = 0.1;\n  const similarityMatrix: number[][] = [];\n  \n  for (let i = 0; i < sentences.length; i++) {\n    similarityMatrix[i] = [];\n    for (let j = 0; j < sentences.length; j++) {\n      const similarity = cosineSimilarity(sentences[i], sentences[j]);\n      similarityMatrix[i][j] = similarity > threshold ? similarity : 0;\n    }\n  }\n  \n  // Normalize rows\n  for (let i = 0; i < sentences.length; i++) {\n    const rowSum = similarityMatrix[i].reduce((a, b) => a + b, 0);\n    if (rowSum > 0) {\n      for (let j = 0; j < sentences.length; j++) {\n        similarityMatrix[i][j] /= rowSum;\n      }\n    }\n  }\n  \n  // Power iteration\n  const scores = new Array(sentences.length).fill(1 / sentences.length);\n  const iterations = 50;\n  \n  for (let iter = 0; iter < iterations; iter++) {\n    const newScores = new Array(sentences.length).fill(0);\n    for (let i = 0; i < sentences.length; i++) {\n      for (let j = 0; j < sentences.length; j++) {\n        newScores[i] += similarityMatrix[j][i] * scores[j];\n      }\n    }\n    scores.splice(0, scores.length, ...newScores);\n  }\n  \n  // Get top sentences\n  const rankedSentences = sentences\n    .map((sentence, index) => ({ sentence, score: scores[index], index }))\n    .sort((a, b) => b.score - a.score)\n    .slice(0, numSentences)\n    .sort((a, b) => a.index - b.index);\n  \n  const summary = rankedSentences.map(item => item.sentence).join('. ') + '.';\n  \n  return {\n    method: 'LexRank',\n    summary,\n    sentences: rankedSentences.map(item => item.sentence),\n    processingTime: Date.now() - startTime\n  };\n}\n\n// Simple extractive summarization (frequency-based)\nexport function frequencyBasedSummarize(text: string, numSentences: number = 3): SummaryResult {\n  const startTime = Date.now();\n  const sentences = tokenizeSentences(text);\n  \n  if (sentences.length <= numSentences) {\n    return {\n      method: 'Frequency-Based',\n      summary: sentences.join('. ') + '.',\n      sentences,\n      processingTime: Date.now() - startTime\n    };\n  }\n  \n  // Calculate word frequencies\n  const words = text.toLowerCase().match(/\\b\\w+\\b/g) || [];\n  const wordFreq: { [key: string]: number } = {};\n  \n  words.forEach((word: string) => {\n    if (word.length > 3) { // Ignore short words\n      wordFreq[word] = (wordFreq[word] || 0) + 1;\n    }\n  });\n  \n  // Score sentences based on word frequencies\n  const sentenceScores: number[] = sentences.map((sentence: string) => {\n    const sentenceWords: string[] = sentence.toLowerCase().match(/\\b\\w+\\b/g) || [];\n    const score: number = sentenceWords.reduce((sum: number, word: string) => sum + (wordFreq[word] || 0), 0);\n    return score / sentenceWords.length; // Normalize by sentence length\n  });\n  \n  // Get top sentences\n  const rankedSentences = sentences\n    .map((sentence, index) => ({ sentence, score: sentenceScores[index], index }))\n    .sort((a, b) => b.score - a.score)\n    .slice(0, numSentences)\n    .sort((a, b) => a.index - b.index);\n  \n  const summary = rankedSentences.map(item => item.sentence).join('. ') + '.';\n  \n  return {\n    method: 'Frequency-Based',\n    summary,\n    sentences: rankedSentences.map(item => item.sentence),\n    processingTime: Date.now() - startTime\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}